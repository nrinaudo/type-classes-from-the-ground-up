<!DOCTYPE html>
<html>
  <head>
    <title>Type Classes from the Ground Up</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
  </head>
  <body>
      <textarea id="source">
class: center, middle

# Type Classes from the Ground Up

Nicolas Rinaudo â€¢ [`@NicolasRinaudo`](https://twitter.com/NicolasRinaudo) â€¢ [ioSquare](http://iosquare.com)

---

## Goals

* Understand what purpose type classes serve
* Get a feel for implicit composition

--

## Running example: CSV parser

CSV data is composed of rows, each row is composed of cells.

```csv
1,Nicolas,Rinaudo
2,Jessica,Jones
3,Matt,Murdock
```

---

## Simple CSV parser

```scala
def parseCsv(input: String): List[List[String]] =
  input.split('\n').toList.map(_.split(",").toList)
```

We purposefully ignore the following flaws:

* cannot handle "complex" CSV data
* inefficient, both in terms of CPU and memory

???

For a real-life scenario, we could consider relegating the parsing to a dedicated library like jackson-csv.

---

## Basic example: raw numbers

```scala
val input = "1,2,3\n4,5,6\n7,8,9"
// input: String =
// 1,2,3
// 4,5,6
// 7,8,9
```

--

Running the parser yields:

```scala
parseCsv(input)
// res0: List[List[String]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

--

Representing clear numeric values as `String`s is unsatisfactory.

---

## Improvement: mapping to `Int`

```scala
parseCsv(input).map(_.map(_.toInt))
// res1: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

--

Not very practical: one has to manually parse `Int`s every time.

---

## Decoding CSV: first attempt

Usual answer to making reusable code: Î»-functions

```scala
def decodeCsv[A](input: String)(f: String â‡’ A): List[List[A]] =
  parseCsv(input).map(_.map(f))
```

--

Running the decoder yields:

```scala
decodeCsv(input)(_.toInt)
// res2: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

--

Better, but not great: one has to manually convert values to the desired type every time.

---

## Small detour: implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as `implicit` in scope, then the compiler will use that value.

???

This is very simplified. We could also talk about:
- implicit scope
- when two acceptable implicit values are found, priority rules apply
- when two acceptable implicit values are found with the same priority, compilation fails.

--

```scala
implicit val a: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

--

Running `printInt` without a parameter:

```scala
printInt
// 2
```

---

## Decoding CSV with implicits

Declare an implicit decoding function parameter:

```scala
def decodeCsv[A](input: String)
                (implicit f: String â‡’ A): List[List[A]] =
  parseCsv(input).map(_.map(f))

implicit val strToInt: String â‡’ Int = Integer.parseInt
```

--

Running the decoder without a decoding function yields:

```scala
decodeCsv[Int](input)
// res6: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

???

This is the first time explicit type parameters are used. Does everyone understand that syntax?

- a function has two kinds of parameters: types and values
- types are usually inferred and do not need to be specified
- it's possible and sometimes necessary to pass them explicitly


---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `T`, but there exists an implicit `S` â‡’ `T`
> in scope, it will be applied silently.

This is called implicit conversion, and can result in some tricky behaviours:

--

```scala
def add1(i: Int): Int = i + 1
// add1: (i: Int)Int

add1("123")
// res7: Int = 124
```

???

* Implicit search is also one of the slowest parts of the compiler. Bringing implicit functions in scope can
  slow compilation quite a bit.

---

## Using a decoder type

To avoid the pitfalls of arbitrary implicit conversions, declare a dedicated type:

```scala
trait CellDecoder[T] {
  def decode(cell: String): T
}

implicit val intCellDecoder: CellDecoder[Int] =
  new CellDecoder[Int] {
    override def decode(cell: String) = cell.toInt
  }
```

--

We just invented _type classes_.

---

## Type class backed decoder

We can now rewrite `decodeCsv`:

```scala
def decodeCsv[A](input: String)
                (implicit da: CellDecoder[A]): List[List[A]] =
  parseCsv(input).map(_.map(da.decode))
```

--

And run it as expected:

```scala
decodeCsv[Int](input)
// res9: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

???

There is a better syntax for this: context bounds.

---

## Enhancement without inheritance!

Important realisation: _we've added a new behaviour to `Int`, even though it's `final`_.

--

Think about implementing the same with subtyping:

* create a `Decodable` interface.

--

* have `Int` implement `Decodable`.

--

* but `Int` is final...

--

* create... `WrappedInt` that implements `Decodable` and proxies all calls to `Int`?

--

* ðŸ˜±


---

## Heterogenous types

`decodeCsv` can decode our input. But what about:

```scala
val input = "1,Nicolas\n2,Jessica\n3,Matt"
// input: String =
// 1,Nicolas
// 2,Jessica
// 3,Matt
```

--

This could be decoded as a `(Int, String)`.

Problem: we only know how to decode rows of homogenous types.

---

## `RowDecoder` type class

We need a decoder type class for rows:

```scala
trait RowDecoder[T] {
  def decode(cells: List[String]): T
}
```

--

`decodeCsv` now looks like:

```scala
def decodeCsv[A](input: String)
                (implicit da: RowDecoder[A]): List[A] =
  parseCsv(input).map(da.decode)
```

---

## First, a bit of plumbing

Let's make instance creation less of a pain:

```scala
def cellDecoder[A](f: String â‡’ A) = new CellDecoder[A] {
  override def decode(cell: String) = f(cell)
}

def rowDecoder[A](f: List[String] â‡’ A) = new RowDecoder[A] {
  override def decode(cells: List[String]) = f(cells)
}

```

--

Also, create a bunch of useful `CellDecoder` instances:

```scala
implicit val intCellDecoder     = cellDecoder(_.toInt)
implicit val floatCellDecoder   = cellDecoder(_.toFloat)
implicit val stringCellDecoder  = cellDecoder(identity)
implicit val booleanCellDecoder = cellDecoder(_.toBoolean)
```

???

Default instances should be declared in the companion object, it's just not very convenient here.

---

## First attempt at decoding tuples

```scala
implicit val tupleDecoder: RowDecoder[(Int, String)] =
  rowDecoder(cells â‡’ (cells(0).toInt, cells(1)))
```

--

This works:

```scala
decodeCsv[(Int, String)](input)
// res12: List[(Int, String)] = List((1,Nicolas), (2,Jessica), (3,Matt))
```

--

Disapointing, though: parsing of individual cells is hard-coded.

Didn't we just write a mechanism for that?

---

## Using `CellDecoder`, take 1

Naive implementation:

```scala
implicit val tupleDecoder: RowDecoder[(Int, String)] =
  rowDecoder { cells â‡’ (
    intCellDecoder.decode(cells(0)),
    stringCellDecoder.decode(cells(1))
  )}
```

--

The decoder instances are hard-coded - always a sign that things can be made more generic.

---

## Another look at implicit resolution

There's another rule used in implicit resolution:

> When the compiler looks for an implicit values of type `T` and finds an implicit function that returns a `T` that
> it can call, it will use its return value.

--

```scala
implicit val d: Double = 3.0

implicit def getFloat(implicit d: Double): Float =
  d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

--
Running `printFloat` without a parameter:

```scala
printFloat
// 3.0
```

???

This can be a bit hard to follow, go through the steps:
- `printFloat` looks for an implicit `Float`
- `getFloat` might produce an implicit `Float`, but needs an implicit `Double`
- `double` is an implicit `Double`

---

## Using `CellDecoder`, take 2

Better implementation:

```scala
implicit def tupleDecoder(
    implicit di: CellDecoder[Int],
             ds: CellDecoder[String]
  ): RowDecoder[(Int, String)] =
  rowDecoder(cells â‡’ (di.decode(cells(0)), ds.decode(cells(1))))
```

--

This produces the desired result:

```scala
decodeCsv[(Int, String)](input)
// res16: List[(Int, String)] = List((1,Nicolas), (2,Jessica), (3,Matt))
```

--

`Int` and `String` are hard-coded, but not used - a strong hint that they should be type parameters.

---

## Using `CellDecoder`, take 3

Fully generic implementation:

```scala
implicit def tupleDecoder[A, B](
    implicit da: CellDecoder[A],
             db: CellDecoder[B]
  ): RowDecoder[(A, B)] =
  rowDecoder(cells â‡’ (da.decode(cells(0)), db.decode(cells(1))))
```

???

You can think of the implicit parameters as constraints on `A` and `B` - `decode` accepts any two types `A` and `B`
that fulfill the constraint of being decodable as cells.

--

Take a minute to let that sink in:

_We've written an instance of `RowDecoder[(A, B)]` for all `A` and `B` that have a `CellDecoder` instance_.

---

## Implicit resolution steps

```scala
decodeCsv[(Float, String)](input)
// res17: List[(Float, String)] = List((1.0,Nicolas), (2.0,Jessica), (3.0,Matt))
```

We need an implicit `RowDecoder[(Float, String)]`.

--

`tupleDecoder` might produce one:

```scala
decodeCsv(input)(tupleDecoder[Float, String])
```

We now need implicit `CellDecoder[Float]` and `CellDecoder[String]` instances.

--

`floatCellDecoder` and `stringCellDecoder` work:

```scala
decodeCsv(input)(tupleDecoder(floatCellDecoder, stringCellDecoder))
```

???

Interesting how the type parameters move to the right and disappear as the compiler uses more and more specialised
instances.

---

## Optional cells

Sometimes, CSV cells are absent or empty:

```scala
val input = "1,Nicolas\n,Jessica\n3,Matt"
// input: String =
// 1,Nicolas
// ,Jessica
// 3,Matt
```

--

This is what `Option` is made for.

```scala
implicit def optionCellDecoder[A](
    implicit da: CellDecoder[A]
  ): CellDecoder[Option[A]] = cellDecoder {
  case "" â‡’ None
  case s  â‡’ Some(da.decode(s))
}
```

---

## Optional cells (2)

This yields the expected result:

```scala
decodeCsv[(Option[Int], String)](input)
// res20: List[(Option[Int], String)] = List((Some(1),Nicolas), (None,Jessica), (Some(3),Matt))
```

--

_We've written an instance of `CellDecoder[Option[A]]` for all `A` that have a `CellDecoder` instance._

---

## Cells with multiple types

"Sometimes", CSV data is messy:

```scala
val input = "1,Nicolas\ntrue,Jessica"
// input: String =
// 1,Nicolas
// true,Jessica
```

--

We have `Either` to represent these cases:

```scala
implicit def eitherCellDecoder[A, B](implicit
    da: CellDecoder[A],
    db: CellDecoder[B]
  ): CellDecoder[Either[A, B]] = cellDecoder { cell â‡’
    try { Left(da.decode(cell)) }
    catch { case _: Throwable â‡’ Right(db.decode(cell)) }
  }
```

???

* Mention alternative `Either` encodings, such as `scalaz.\/`

---

## Cells with multiple types (2)

This yields the expected result:

```scala
decodeCsv[(Either[Int, Boolean], String)](input)
// res21: List[(Either[Int,Boolean], String)] = List((Left(1),Nicolas), (Right(true),Jessica))
```

--

_We've written an instance of `CellDecoder[Either[A, B]]` for all `A` and `B` that have a `CellDecoder` instance._

---

## Complex compositions

```scala
val input = "1,Nicolas\nfalse,Jessica\n,Matt"
// input: String =
// 1,Nicolas
// false,Jessica
// ,Matt
```

The first column looks like an `Option[Either[Int, Boolean]]`.

--

We already have `Either` and `Option` instances, so we get this for free:

```scala
decodeCsv[(Option[Either[Int, Boolean]], String)](input)
// res22: List[(Option[Either[Int,Boolean]], String)] = List((Some(Left(1)),Nicolas), (Some(Right(false)),Jessica), (None,Matt))
```



---

## Collections of values

We have lost the ability to decode a row as `List[Int]` on the way:

```scala
val input = "1,2,3\n4,5,6"
// input: String =
// 1,2,3
// 4,5,6
```

--

Easily fixed:

```scala
implicit def listDecoder[A](
  implicit da: CellDecoder[A]
  ): RowDecoder[List[A]] =
  rowDecoder(_.foldLeft(List.newBuilder[A]) { (acc, cell) â‡’
    acc += da.decode(cell)
  }.result())
```

---

## Collections of values (2)

This yields the expected result:

```scala
decodeCsv[List[Int]](input)
// res23: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6))
```

--

_We've written an instance of `RowDecoder[List[A]]` for any `A` that has a `CellDecoder` instance._

--

We could do it for _any collection type_ by using
[`CanBuildFrom`](http://www.scala-lang.org/api/2.11.8/#scala.collection.generic.CanBuildFrom), but it relies on a few
advanced concepts that are off-topic here.

???

```scala
import scala.collection.generic.CanBuildFrom

implicit def collectionDecoder[A, C[_]]
               (implicit da: CellDecoder[A],
                         cbf: CanBuildFrom[Nothing, A, C[A]]) =
  rowDecoder(_.foldLeft(cbf.apply()) { (out, s) â‡’
    out += da.decode(s)
  }.result())
```

---

## Case classes

We *could* write a `RowDecoder[A]` instance for any case class `A`â€¦

--

â€¦ but I'd have to use [shapeless](http://shapeless.io), and this would turn into a different talk entirely.

---

## Conclusions

Type classes:
* are great at adding new behaviours to existing types

```scala
implicit val uuidDecoder = cellDecoder(java.util.UUID.fromString)
```

--

* compose implicitly, without having to write any type specific code

```scala
implicitly[RowDecoder[List[Either[Int, Option[Either[Boolean, java.util.UUID]]]]]]
// res25: RowDecoder[List[Either[Int,Option[Either[Boolean,java.util.UUID]]]]] = $anon$1@529973c1
```

---

## More information

Find me on Twitter ([`@NicolasRinaudo`](https://twitter.com/NicolasRinaudo))

Make fun of my code on Github ([`nrinaudo`](https://github.com/nrinaudo/))

See [kantan.csv](http://nrinaudo.github.io/kantan.csv/) for a concrete, usable implementation

Get in touch with [`ioSquare`](http://iosquare.com), we're always on the lookout for Scala talent

Slides backed by [remark.js](https://remarkjs.com/) and Rob Norris' amazing [tut](https://github.com/tpolecat/tut)



---
class: center, middle

# Thanks!

    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
        highlightStyle: 'solarized-dark'
      });
    </script>
  </body>
</html>
